<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Інтерактивна таблиця — баланс реакції + вектори (fixed layout)</title>

<style>
  :root{ --accent:#2a9df4; --pos:#1e6ed1; --neg:#d13b3b; --border:#9aa; }
  /* Box sizing reset to avoid unexpected overflow */
  *, *::before, *::after { box-sizing: border-box; }

  body{background:#f6f9fc; margin:0; padding:0; font-family:Arial, sans-serif; color:#222;}
  /* Make chem-wrap responsive and not wider than viewport */
  .chem-wrap{
    max-width:1200px;
    width:calc(100% - 32px);
    margin:24px auto;
    background:#fff;
    padding:16px;
    border-radius:12px;
    box-shadow:0 2px 6px rgba(0,0,0,0.08);
    overflow:hidden; /* hide accidental overflow */
  }

  .title{text-align:center; font-weight:700; margin-bottom:6px; font-size:20px;}
  .eq{ text-align:center; margin-bottom:12px; font-size:18px;}
  .formula-box{display:flex; gap:8px; justify-content:center; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
  .formula-part{display:inline-flex; align-items:center; gap:6px; font-weight:600;}

  .controls-row{display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:12px; flex-wrap:wrap;}

  /* layout: allow right column to shrink but not disappear, prevents overflow */
  .layout{
    display:grid;
    grid-template-columns: 1fr minmax(280px, 480px);
    gap:16px;
    align-items:start;
  }
  @media (max-width:1100px){ .layout{grid-template-columns:1fr;} }

  table.chem{border-collapse:collapse; width:100%;}
  table.chem caption{caption-side:top; font-weight:700; margin-bottom:8px; text-align:left;}
  table.chem th, table.chem td{border:1px solid var(--border); padding:6px; text-align:center; min-width:46px; background:#fff; vertical-align:middle;}
  table.chem th{background:#e6f0fb; font-weight:700;}
  .elem-cell{background:#fafafa; font-weight:600;}
  input.num{width:100%; border:0; text-align:center; font-size:14px; padding:4px; background:transparent;}
  input.num:focus{outline:1px solid var(--accent); background:#eef7ff;}
  .coef{width:48px; padding:4px; text-align:center; border-radius:6px; border:1px solid #d7eafb; background:#f8fbff;}
  .mol-header{display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center;}
  .mol-name{font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:80px;}
  .mol-coef-label{font-size:11px; color:#555;}
  .rp-cell{min-height:36px; min-width:64px; display:flex; align-items:center; justify-content:center; background:#fff; transition:color 0.15s, background 0.15s;}
  .rp-zero{color:#333;}
  .rp-pos{color:var(--pos); font-weight:700;}
  .rp-neg{color:var(--neg); font-weight:700;}
  .note{font-size:13px; color:#555; text-align:center; margin-top:8px;}
  .mol-fallback{opacity:0.7; font-style:italic;}
  .rp-header{ white-space:nowrap; vertical-align:middle; }

  /* vector panel: responsive; doesn't force width beyond container */
  .vector-panel{
    background:#fff;
    border:1px solid #e2eefc;
    border-radius:10px;
    padding:8px;
    max-width:100%;
    overflow:hidden; /* clip anything that would escape */
  }
  .vector-title{font-weight:700; font-size:15px; margin-bottom:8px; text-align:center;}

  /* SVG: scale to container width, keep aspect, and avoid overflow */
  .vector-svg{
    width:100%;
    height:auto;
    display:block;
    background:linear-gradient(180deg,#fbfeff,#f7fbff);
    border-radius:8px;
    border:1px solid #e6f7ff;
    max-width:100%;
    overflow:hidden;
  }

  /* Axis labels moved to HTML block under SVG to avoid overlapping ticks/markers */
  .axis-labels{display:flex; justify-content:space-between; align-items:center; margin-top:6px; gap:8px; padding:0 6px;}
  .axis-labels .x-label{flex:1; text-align:center; font-weight:600; color:#234;}
  .axis-labels .y-label{width:48px; text-align:left; font-weight:600; color:#234;}
  .vector-legend{font-size:13px; margin-top:8px; color:#444; text-align:center;}
  .axis-selectors{display:flex; gap:8px; justify-content:center; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
  .axis-selectors label{font-size:13px; color:#333;}

  @media (max-width:880px){
    .coef{width:40px;}
    table.chem th, table.chem td{font-size:13px; padding:6px;}
    .formula-box{font-size:15px;}
  }
</style>
</head>
<body>

<div class="chem-wrap">
  <div class="title">Інтерактивна таблиця — баланс реакції + вектори</div>

  <div class="eq" aria-live="polite">
    <div class="formula-box" id="equation"></div>
    <div style="font-size:13px; color:#444;">(Реагенти зліва — Продукти справа)</div>
  </div>

  <div class="controls-row">
    <div style="font-size:13px; color:#444;">Оберіть осі для векторів (X, Y):</div>
    <div class="axis-selectors" id="axisSelectors"></div>
  </div>

  <div class="layout">
    <div>
      <table class="chem" id="mainTable" aria-label="Таблиця елементів і молекул">
        <caption>Таблиця атомних індексів у молекулах і вектори по осях</caption>
        <thead>
          <tr>
            <th scope="col" rowspan="2">Елемент</th>
            <th scope="col" rowspan="2">X</th>
            <th scope="col" rowspan="2">Y</th>
            <th scope="col" colspan="3">Реагенти</th>
            <th scope="col" rowspan="2" class="rp-header">R − P</th>
            <th scope="col" colspan="5">Продукти</th>
          </tr>
          <tr id="moleculeHeaders"></tr>
        </thead>
        <tbody id="elementsBody"></tbody>
      </table>

      <div class="note">Змінюй числа індексів або коефіцієнти — рівняння, різниця (R − P) та вектори оновлюються автоматично. Якщо коефіцієнт 0 — молекулу не показуємо; 1 — цифру 1 не показуємо.</div>
    </div>

    <div class="vector-panel" aria-label="Панель векторів">
      <div class="vector-title">Координатна сітка 0…10 — вектори молекул</div>

      <!-- SVG: preserveAspectRatio so scaling stays centered and inside bounds -->
      <svg id="vectorSvg" class="vector-svg" viewBox="0 0 520 520" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Координатна сітка"></svg>

      <!-- axis labels moved to HTML under SVG to avoid overlap -->
      <div class="axis-labels" aria-hidden="false">
        <div class="y-label" id="axisLabelY">Y:</div>
        <div class="x-label" id="axisLabelX">X:</div>
      </div>

      <div class="vector-legend" id="vectorLegend">Координати: (X, Y) — значення кількостей елементів по вибраних осях. Кількість маркерів для молекули = її коефіцієнт.</div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const elements = ["H","C","O","N","P","S","F","Na","Ca"];
  const reactants = [
    {id:"h2o", label:"H2O"},
    {id:"co2", label:"CO2"},
    {id:"o2",  label:"O2"}
  ];
  const products = [
    {id:"h2",   label:"H2"},
    {id:"o3",   label:"O3"},
    {id:"h2co3",label:"H2CO3"},
    {id:"n2",   label:"N2"},
    {id:"nh3",  label:"NH3"}
  ];

  // --- Заголовки молекул
  const headerRow = document.getElementById("moleculeHeaders");
  function makeMolHeaderCell(mol){
    const th = document.createElement("th");
    th.setAttribute("scope","col");
    th.innerHTML = `
      <div class="mol-header">
        <div class="mol-name" data-mol="${mol.id}" id="name_${mol.id}" title="${mol.label}">${mol.label}</div>
        <div class="mol-coef-label">
          <input class="coef" aria-label="Коефіцієнт ${mol.label}" data-mol="${mol.id}" type="number" min="0" step="1" value="1">
        </div>
      </div>`;
    return th;
  }
  reactants.forEach(m => headerRow.appendChild(makeMolHeaderCell(m)));
  products.forEach(m => headerRow.appendChild(makeMolHeaderCell(m)));

  // --- Тіло таблиці (з X/Y радіо)
  const body = document.getElementById("elementsBody");
  elements.forEach((elem, idx) => {
    const tr = document.createElement("tr");
    const tdElem = document.createElement("td"); tdElem.className = "elem-cell"; tdElem.textContent = elem; tr.appendChild(tdElem);
    const tdX = document.createElement("td"); tdX.innerHTML = `<input type="radio" name="axis-x" aria-label="Обрати ${elem} як X" value="${elem}" ${idx===0 ? "checked" : ""}>`; tr.appendChild(tdX);
    const tdY = document.createElement("td"); tdY.innerHTML = `<input type="radio" name="axis-y" aria-label="Обрати ${elem} як Y" value="${elem}" ${idx===1 ? "checked" : ""}>`; tr.appendChild(tdY);

    reactants.forEach(m => {
      const td = document.createElement("td");
      td.innerHTML = `<input class="num cell left" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="Індекс елемента ${elem} в молекулі ${m.label}">`;
      tr.appendChild(td);
    });

    const rpTd = document.createElement("td"); rpTd.className = "rp-cell"; rpTd.id = `rp_${elem}`; rpTd.textContent = "0"; tr.appendChild(rpTd);

    products.forEach(m => {
      const td = document.createElement("td");
      td.innerHTML = `<input class="num cell right" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="Індекс елемента ${elem} в молекулі ${m.label}">`;
      tr.appendChild(td);
    });

    body.appendChild(tr);
  });

  function defaultIndex(mol, elem){
    const map = {
      h2o: {H:2,O:1},
      co2: {C:1,O:2},
      o2:  {O:2},
      h2:  {H:2},
      o3:  {O:3},
      h2co3:{H:2,C:1,O:3},
      n2:  {N:2},
      nh3: {N:1,H:3}
    };
    return (map[mol] && map[mol][elem]) ? map[mol][elem] : 0;
  }

  function qAll(selector){ return Array.from(document.querySelectorAll(selector)); }
  function q(selector){ return document.querySelector(selector); }

  function buildFormulaHTML(molId){
    const parts = [];
    elements.forEach(el => {
      const input = document.querySelector(`.cell[data-mol="${molId}"][data-elem="${el}"]`);
      const val = input ? Number(input.value) || 0 : 0;
      if(val > 0) parts.push(el + (val > 1 ? `${val}` : ""));
    });
    return parts.length ? parts.join("") : `<span class="mol-fallback">${molId}</span>`;
  }

  function buildEquation(){
    const leftParts = [];
    reactants.forEach(m => {
      const coefInput = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Math.max(0, Math.floor(Number(coefInput.value) || 0)) : 0;
      if(coef === 0) return;
      const formula = buildFormulaHTML(m.id);
      leftParts.push((coef>1?coef:'') + formula);
    });
    const rightParts = [];
    products.forEach(m => {
      const coefInput = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Math.max(0, Math.floor(Number(coefInput.value) || 0)) : 0;
      if(coef === 0) return;
      const formula = buildFormulaHTML(m.id);
      rightParts.push((coef>1?coef:'') + formula);
    });

    const joiner = ' <span style="color:#666; font-weight:600">+</span> ';
    const leftHTML = leftParts.length ? leftParts.join(joiner) : '<span style="color:#999">—</span>';
    const rightHTML = rightParts.length ? rightParts.join(joiner) : '<span style="color:#999">—</span>';
    document.getElementById("equation").innerHTML = `<div class="formula-part">${leftHTML}</div><div style="font-weight:700; padding:0 8px"> = </div><div class="formula-part">${rightHTML}</div>`;
  }

  function updateDifference(){
    elements.forEach(elem => {
      let leftSum = 0;
      qAll(`.left[data-elem="${elem}"]`).forEach(input => leftSum += Number(input.value) || 0);
      let rightSum = 0;
      qAll(`.right[data-elem="${elem}"]`).forEach(input => rightSum += Number(input.value) || 0);
      const diff = leftSum - rightSum;
      const cell = document.getElementById(`rp_${elem}`);
      if(!cell) return;
      cell.textContent = diff;
      cell.classList.remove("rp-pos","rp-neg","rp-zero");
      if(diff > 0) cell.classList.add("rp-pos");
      else if(diff < 0) cell.classList.add("rp-neg");
      else cell.classList.add("rp-zero");
    });
  }

  // --- SVG grid & vectors (with clamping to avoid overflow)
  const svg = document.getElementById("vectorSvg");
  svg.setAttribute('overflow','hidden');
  const svgSize = 520;
  const padding = 40; // inner margin so nothing touches panel border
  const coordMin = 0;
  const coordMax = 10;
  const gridCount = coordMax - coordMin + 1;

  function drawGrid(){
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    // defs for arrowheads (create palette-aware arrow markers)
    const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
    const palette = ["#e85d5d","#5da0e8","#5de89a","#e8c95d","#b35de8","#5de0e8","#e85dc4","#8fbf5d","#5d7fe8","#d1863a"];
    palette.forEach((col, i) => {
      const m = document.createElementNS("http://www.w3.org/2000/svg","marker");
      const id = `arrowhead-${i}`;
      m.setAttribute("id", id);
      m.setAttribute("markerWidth", "8");
      m.setAttribute("markerHeight", "8");
      m.setAttribute("refX", "6");
      m.setAttribute("refY", "3.5");
      m.setAttribute("orient", "auto");
      m.setAttribute("markerUnits", "strokeWidth");
      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d","M0,0 L8,3.5 L0,7 z");
      path.setAttribute("fill", col);
      m.appendChild(path);
      defs.appendChild(m);
    });
    svg.appendChild(defs);

    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x","0"); bg.setAttribute("y","0"); bg.setAttribute("width","520"); bg.setAttribute("height","520");
    bg.setAttribute("fill","transparent");
    svg.appendChild(bg);

    const innerSize = svgSize - padding*2;
    const step = innerSize / (coordMax - coordMin);

    // dots and ticks
    for(let i=0;i<gridCount;i++){
      const x = padding + i*step;
      for(let j=0;j<gridCount;j++){
        const y = padding + (gridCount-1-j)*step;
        const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
        dot.setAttribute("cx", x.toString());
        dot.setAttribute("cy", y.toString());
        dot.setAttribute("r", "2");
        dot.setAttribute("fill", "#d9eefe");
        svg.appendChild(dot);
      }

      // X ticks: place just above the bottom margin reserved for axis-label HTML
      const tx = document.createElementNS("http://www.w3.org/2000/svg","text");
      tx.setAttribute("x", (padding + i*step).toString());
      tx.setAttribute("y", (svgSize - Math.round(padding/2) - 6).toString());
      tx.setAttribute("font-size", "10");
      tx.setAttribute("fill", "#436");
      tx.setAttribute("text-anchor","middle");
      tx.textContent = String(coordMin + i);
      svg.appendChild(tx);

      // Y ticks (left)
      const ty = document.createElementNS("http://www.w3.org/2000/svg","text");
      ty.setAttribute("x", String(12));
      ty.setAttribute("y", (padding + (gridCount-1-i)*step + 3).toString());
      ty.setAttribute("font-size", "10");
      ty.setAttribute("fill", "#436");
      ty.setAttribute("text-anchor","start");
      ty.textContent = String(coordMin + i);
      svg.appendChild(ty);
    }

    // axes (inside padding)
    const axisX = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisX.setAttribute("x1", padding.toString());
    axisX.setAttribute("y1", (svgSize - padding).toString());
    axisX.setAttribute("x2", (svgSize - padding).toString());
    axisX.setAttribute("y2", (svgSize - padding).toString());
    axisX.setAttribute("stroke","#79a9d9");
    axisX.setAttribute("stroke-width","1.5");
    svg.appendChild(axisX);

    const axisY = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisY.setAttribute("x1", padding.toString());
    axisY.setAttribute("y1", padding.toString());
    axisY.setAttribute("x2", padding.toString());
    axisY.setAttribute("y2", (svgSize - padding).toString());
    axisY.setAttribute("stroke","#79a9d9");
    axisY.setAttribute("stroke-width","1.5");
    svg.appendChild(axisY);
  }

  function getSelectedAxes(){
    const x = q('input[name="axis-x"]:checked')?.value || elements[0];
    const y = q('input[name="axis-y"]:checked')?.value || elements[1] || elements[0];
    return { x, y };
  }

  function drawVectors(){
    drawGrid();

    const innerSize = svgSize - padding*2;
    const step = innerSize / (coordMax - coordMin);
    const axes = getSelectedAxes();

    // update HTML axis labels (outside SVG) so they never overlap ticks or markers
    const axisLabelX = document.getElementById('axisLabelX');
    const axisLabelY = document.getElementById('axisLabelY');
    if(axisLabelX) axisLabelX.textContent = `X: ${axes.x}`;
    if(axisLabelY) axisLabelY.textContent = `Y: ${axes.y}`;

    const grp = document.createElementNS("http://www.w3.org/2000/svg","g");
    grp.setAttribute("id","vectorsGroup");
    svg.appendChild(grp);

    const palette = ["#e85d5d","#5da0e8","#5de89a","#e8c95d","#b35de8","#5de0e8","#e85dc4","#8fbf5d","#5d7fe8","#d1863a"];
    const allMols = [...reactants, ...products];

    const minC = padding + 6;           // increased margin to avoid touching edge
    const maxC = svgSize - padding - 6; // increased margin to avoid touching edge

    // Build flat list of instances (one entry per visible marker)
    const instances = [];
    allMols.forEach((mol, mi) => {
      const coefInput = q(`.coef[data-mol="${mol.id}"]`);
      const coef = coefInput ? Math.max(0, Math.floor(Number(coefInput.value) || 0)) : 0;
      if(coef <= 0) return;

      const xCountInput = q(`.cell[data-mol="${mol.id}"][data-elem="${axes.x}"]`);
      const yCountInput = q(`.cell[data-mol="${mol.id}"][data-elem="${axes.y}"]`);
      const xCount = xCountInput ? Math.max(0, Math.floor(Number(xCountInput.value) || 0)) : 0;
      const yCount = yCountInput ? Math.max(0, Math.floor(Number(yCountInput.value) || 0)) : 0;

      if(xCount===0 && yCount===0) return;

      for(let k=0;k<coef;k++){
        instances.push({
          mol, mi, xVal: Math.min(coordMax, Math.max(coordMin, xCount)),
          yVal: Math.min(coordMax, Math.max(coordMin, yCount)),
          indexInMol: k
        });
      }
    });

    // Group instances by exact integer coordinate pair, preserve original order
    const groups = {};
    const groupOrder = [];
    instances.forEach(inst => {
      const key = `${inst.xVal}_${inst.yVal}`;
      if(!groups[key]){ groups[key] = []; groupOrder.push(key); }
      groups[key].push(inst);
    });

    // origin in SVG coords (corresponds to (0,0))
    const origin = { x: padding, y: svgSize - padding };

    // For each group draw chained arrows: each arrow segment has the vector from origin -> gridCell
    groupOrder.forEach((key) => {
      const group = groups[key];
      if(!group || group.length === 0) return;
      // compute single-step end point for that coordinate (one vector length)
      const xVal = group[0].xVal;
      const yVal = group[0].yVal;
      // end for multiplier 1
      const end1 = {
        x: padding + xVal * step,
        y: padding + (coordMax - yVal) * step
      };
      // vector V = end1 - origin
      const V = { x: end1.x - origin.x, y: end1.y - origin.y };
      const Vlen = Math.sqrt(V.x*V.x + V.y*V.y);
      if(Vlen === 0) return; // skip if somehow at origin (should be filtered out)
      const unit = { x: V.x / Vlen, y: V.y / Vlen };

      // determine maximum whole steps we can draw without exceeding bounding box (keep inside minC..maxC)
      // compute max multiplier so that origin + m*V stays within minC..maxC
      let maxMultiplier = Infinity;
      // check x direction
      if (V.x > 0) {
        maxMultiplier = Math.min(maxMultiplier, (maxC - origin.x) / V.x);
      } else if (V.x < 0) {
        maxMultiplier = Math.min(maxMultiplier, (minC - origin.x) / V.x);
      } else {
        // V.x == 0 doesn't constrain
      }
      // check y direction
      if (V.y > 0) {
        maxMultiplier = Math.min(maxMultiplier, (maxC - origin.y) / V.y);
      } else if (V.y < 0) {
        maxMultiplier = Math.min(maxMultiplier, (minC - origin.y) / V.y);
      }

      // Allow a small epsilon
      maxMultiplier = Math.max(0, Math.floor(maxMultiplier + 1e-6));

      // number of arrows we will try to draw is limited by group.length and maxMultiplier
      const drawCount = Math.min(group.length, Math.max(0, maxMultiplier));

      for(let i=0;i<drawCount;i++){
        const inst = group[i];
        // compute start and end of this segment: start = origin + i*V, end = origin + (i+1)*V
        const start = { x: origin.x + i * V.x, y: origin.y + i * V.y };
        const end = { x: origin.x + (i+1) * V.x, y: origin.y + (i+1) * V.y };

        // clamp to bounds just in case
        start.x = Math.min(maxC, Math.max(minC, start.x));
        start.y = Math.min(maxC, Math.max(minC, start.y));
        end.x = Math.min(maxC, Math.max(minC, end.x));
        end.y = Math.min(maxC, Math.max(minC, end.y));

        // draw line with arrowhead; color per molecule index
        const color = palette[inst.mi % palette.length];
        const line = document.createElementNS("http://www.w3.org/2000/svg","line");
        line.setAttribute("x1", start.x.toString());
        line.setAttribute("y1", start.y.toString());
        line.setAttribute("x2", end.x.toString());
        line.setAttribute("y2", end.y.toString());
        line.setAttribute("stroke", color);
        line.setAttribute("stroke-width", "4");
        line.setAttribute("stroke-linecap", "round");
        line.setAttribute("marker-end", `url(#arrowhead-${inst.mi % palette.length})`);
        line.setAttribute("data-mol", inst.mol.id);
        line.setAttribute("title", `${inst.mol.label} → (${inst.xVal}, ${inst.yVal})`);
        grp.appendChild(line);

        // label: place near segment end, with small perpendicular offset to avoid overlapping the line
        const offset = 12;
        // perpendicular vector to unit: (-uy, ux)
        const px = -unit.y;
        const py = unit.x;
        // label position slightly beyond end point
        let lx = end.x + px * offset;
        let ly = end.y + py * offset + 4; // small vertical nudge for legibility

        // clamp label inside svg bounds
        lx = Math.min(maxC, Math.max(minC + 6, lx));
        ly = Math.min(maxC, Math.max(minC + 6, ly));

        const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
        txt.setAttribute("x", lx.toString());
        txt.setAttribute("y", ly.toString());
        txt.setAttribute("font-size","10");
        txt.setAttribute("fill","#214");
        txt.setAttribute("data-mol", inst.mol.id);
        // shorten very long labels
        const labelText = `${inst.mol.label}${group.length>1?`×${1}`:""}`;
        txt.textContent = labelText.length > 12 ? (labelText.slice(0,11) + '…') : labelText;
        grp.appendChild(txt);
      }

      // If there are more instances than fit fully before the bounds, draw a final shortened arrow to the clamped boundary
      if(group.length > drawCount && drawCount >= 0){
        const remaining = group.length - drawCount;
        // start at origin + drawCount*V, end at origin + maxMultiplier*V (clamped end)
        const start = { x: origin.x + drawCount * V.x, y: origin.y + drawCount * V.y };
        const end = { x: origin.x + maxMultiplier * V.x, y: origin.y + maxMultiplier * V.y };
        start.x = Math.min(maxC, Math.max(minC, start.x));
        start.y = Math.min(maxC, Math.max(minC, start.y));
        end.x = Math.min(maxC, Math.max(minC, end.x));
        end.y = Math.min(maxC, Math.max(minC, end.y));
        // color using last group's molecule color (best-effort)
        const inst = group[drawCount];
        const color = palette[inst.mi % palette.length];
        const line = document.createElementNS("http://www.w3.org/2000/svg","line");
        line.setAttribute("x1", start.x.toString());
        line.setAttribute("y1", start.y.toString());
        line.setAttribute("x2", end.x.toString());
        line.setAttribute("y2", end.y.toString());
        line.setAttribute("stroke", color);
        line.setAttribute("stroke-width", "4");
        line.setAttribute("stroke-linecap", "round");
        line.setAttribute("marker-end", `url(#arrowhead-${inst.mi % palette.length})`);
        line.setAttribute("data-mol", inst.mol.id);
        line.setAttribute("title", `${inst.mol.label} (truncated chain)`);
        grp.appendChild(line);

        const offset = 12;
        const Vlen = Math.sqrt(V.x*V.x + V.y*V.y);
        const unit = { x: V.x / Vlen, y: V.y / Vlen };
        const px = -unit.y;
        const py = unit.x;
        let lx = end.x + px * offset;
        let ly = end.y + py * offset + 4;
        lx = Math.min(maxC, Math.max(minC + 6, lx));
        ly = Math.min(maxC, Math.max(minC + 6, ly));
        const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
        txt.setAttribute("x", lx.toString());
        txt.setAttribute("y", ly.toString());
        txt.setAttribute("font-size","10");
        txt.setAttribute("fill","#214");
        txt.textContent = "…";
        grp.appendChild(txt);
      }
    });

    const anyVectors = svg.querySelectorAll('#vectorsGroup line').length > 0;
    if(!anyVectors){
      const hint = document.createElementNS("http://www.w3.org/2000/svg","text");
      hint.setAttribute("x",(svgSize/2).toString());
      hint.setAttribute("y",(svgSize/2).toString());
      hint.setAttribute("font-size","13");
      hint.setAttribute("fill","#789");
      hint.setAttribute("text-anchor","middle");
      hint.textContent = "Немає видимих векторів (поставте коефіцієнт > 0 або виберіть інші осі)";
      svg.appendChild(hint);
    }
  }

  // build axis selectors and sync with table radios
  const axisSelectors = document.getElementById("axisSelectors");
  function buildAxisSelectors(){
    axisSelectors.innerHTML = "";
    const xGroup = document.createElement("div");
    xGroup.style.display = "flex"; xGroup.style.gap = "8px"; xGroup.style.flexWrap = "wrap"; xGroup.style.alignItems = "center";
    const xLabel = document.createElement("span");
    xLabel.textContent = "X:"; xLabel.style.fontWeight = "600"; xLabel.style.marginRight = "4px";
    xGroup.appendChild(xLabel);

    elements.forEach((el, idx) => {
      const lab = document.createElement("label");
      lab.style.display = "inline-flex"; lab.style.alignItems = "center"; lab.style.gap = "4px";
      const r = document.createElement("input");
      r.type = "radio"; r.name = "axis-x-controls"; r.value = el; r.checked = (idx === 0);
      r.addEventListener("change", () => {
        const tableRadio = q(`input[name="axis-x"][value="${el}"]`);
        if(tableRadio) tableRadio.checked = true;
        drawVectors();
      });
      lab.appendChild(r);
      const span = document.createElement("span"); span.textContent = el; span.style.fontSize = "13px";
      lab.appendChild(span);
      xGroup.appendChild(lab);
    });

    const yGroup = document.createElement("div");
    yGroup.style.display = "flex"; yGroup.style.gap = "8px"; yGroup.style.flexWrap = "wrap"; yGroup.style.alignItems = "center";
    const yLabel = document.createElement("span");
    yLabel.textContent = "Y:"; yLabel.style.fontWeight = "600"; yLabel.style.marginRight = "4px";
    yGroup.appendChild(yLabel);

    elements.forEach((el, idx) => {
      const lab = document.createElement("label");
      lab.style.display = "inline-flex"; lab.style.alignItems = "center"; lab.style.gap = "4px";
      const r = document.createElement("input");
      r.type = "radio"; r.name = "axis-y-controls"; r.value = el; r.checked = (idx === 1);
      r.addEventListener("change", () => {
        const tableRadio = q(`input[name="axis-y"][value="${el}"]`);
        if(tableRadio) tableRadio.checked = true;
        drawVectors();
      });
      lab.appendChild(r);
      const span = document.createElement("span"); span.textContent = el; span.style.fontSize = "13px";
      lab.appendChild(span);
      yGroup.appendChild(lab);
    });

    axisSelectors.appendChild(xGroup);
    axisSelectors.appendChild(yGroup);

    qAll('input[name="axis-x"]').forEach(r => r.addEventListener('change', () => {
      const val = r.value;
      const control = document.querySelector(`input[name="axis-x-controls"][value="${val}"]`);
      if(control) control.checked = true;
      drawVectors();
    }));
    qAll('input[name="axis-y"]').forEach(r => r.addEventListener('change', () => {
      const val = r.value;
      const control = document.querySelector(`input[name="axis-y-controls"][value="${val}"]`);
      if(control) control.checked = true;
      drawVectors();
    }));
  }

  function onChangeHandler(){
    [...reactants, ...products].forEach(m => {
      const nameEl = document.getElementById(`name_${m.id}`);
      if(nameEl) nameEl.innerHTML = buildFormulaHTML(m.id);
    });
    buildEquation();
    updateDifference();
    drawVectors();
  }

  // event bindings
  qAll("input.num").forEach(inp => inp.addEventListener("input", onChangeHandler));
  qAll("input.coef").forEach(inp => {
    inp.addEventListener("input", () => {
      inp.value = Math.max(0, Math.floor(Number(inp.value) || 0));
      onChangeHandler();
    });
  });

  buildAxisSelectors();

  // initial coefficients
  [...reactants, ...products].forEach(m => {
    const coef = document.querySelector(`.coef[data-mol="${m.id}"]`);
    const any = elements.some(el => {
      const cell = document.querySelector(`.cell[data-mol="${m.id}"][data-elem="${el}"]`);
      return cell && Number(cell.value) > 0;
    });
    if(coef) coef.value = any ? (coef.value || 1) : 0;
  });

  onChangeHandler();

  window.addEventListener('resize', () => drawVectors());
});
</script>

</body>
</html>